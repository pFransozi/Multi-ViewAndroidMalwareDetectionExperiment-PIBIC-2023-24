## Table of Contents

- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [Extract multiple feature sets](#extract-multiple-feature-sets)
- [Preprocessing datasets and PCA transformation](#preprocessing-datasets-and-pca-transformation)
- [Train and test models](#train-and-test-models)
- [NSGA-II: Non-dominated Sorting Genetic Algorithm](#nsga-ii-non-dominated-sorting-genetic-algorithm)
- [Repo Directories](#repo-directories)

## Introduction

This repository stores all files that were used in a multi-view Android malware detection model through multi-objective optimization, which is implemented in two stages, as follows:

1. Extract multiple feature sets from an analyzed Android application package;
2. Select the optimal feature subset from each view for subsequent ensemble-based classification, using multi-objective optimization.

Through this strategy, true-positive accuracy improves by an average of 4.4, demanding only up to 65% of processing costs.

## Extract multiple feature sets

1. Download [AndroZoo dataset](https://androzoo.uni.lu/static/lists/latest.csv.gz);
2. Filter dataset based on a date range and file size. Then, the result is divided between malware and goodware, and downloaded. This [code](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/0.download_apk.py) do that;
3. Extract the static features using [AndroPyTool](https://github.com/alexMyG/AndroPyTool) tool, as follow:
    ```docker
    # pwd = apks directory
    docker run -v $(pwd):/apks alexmyg/andropytool -s /apks -fw
    ```
4. Based on Andropytool generated files, extract the three views, which are Apicalls, Permissions, Opcodes, and generate three files for each one. Each of the files is labeled with the APK hash and a field called class is added. If APK is a malware, class field is assigned 1, otherwise, 0. This [code](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/0.extract_views.py) do that.
5. Then, generate csv files for each view. For all csv files, each line represents the same APK. All columns of each view are based on Andropytool results, except for class column. This [code](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/1.generate_csv_files.ipynb) do that.

## Preprocessing datasets and PCA transformation

All the steps below are repeated for each view and aim to process the datasets, apply a Principal Component Analysis (PCA) to reduce the dimensionality of datasets, generate a numpy array from the PCA-reduced datasets.

1. Read csv files, fill all NaN fields with 0, and drop columns that were created from csv concatenation process;
2. Extract dependent variable (y) and cast it to numpy array, and drop it from dataset;
3. Cast independent variables (x) to numpy array; And apply PCA fit and transformation over new numpy array;
4. Then, save PCA numpy array and dependent variable numpy array.

The codes related to these steps are: [Apicalls](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/2.process_csv_and_generate_np_array_pca_apicalls.ipynb), [Opcodes](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/2.process_csv_and_generate_np_array_pca_opcodes.ipynb), [Permissions](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/2.process_csv_and_generate_np_array_pca_permissions.ipynb).

## Train and test models

All the steps below are repeated for each view, and aim to train and test supervised machine learning models, which are Random Forest, Decision Tree, and KNeighbors. Additionally, generate confusion matrix, roc curve.

1. After loading numpy arrays, they are splitted into train (70%) and test subsets;
2. Using train subset, RandomForestClassifier, DecisionTreeClassifier and KNeighborsClassifier are trained and, then, tested using test subset.
3. Generate confusion matrix and roc curve;

The codes related to these steps are: [Apicalls](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/3.train_test_models_and_metrics_apicalls_pca.ipynb), [Opcodes](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/3.train_test_models_and_metrics_opcodes_pca.ipynb), [Permissions](https://github.com/pFransozi/Multi-viewAndroidMalware/blob/main/src/3.train_test_models_and_metrics_permissions_pca.ipynb).

## NSGA-II: Non-dominated Sorting Genetic Algorithm

This is the second stage of the project, which contributes by proposing a new multiobjective optimization model for multi-view classification of
Android malware. The optimization model was built using [Pymoo](https://pymoo.org/index.html) framework, the [NSGA-2](https://pymoo.org/algorithms/moo/nsga2.html) algorithm.

All steps below are repeated for each view three times, for each supervised machine learning model. Additionally, a majority voting procedure was added for each classifier.

1. To define our problem was used ElementwiseProblem, which implements a function evaluating a single solution at a time. The problem was defined as follows:
   * 100 design variables array, called x;
   * 2 objectives, called F1 and F2;
   * 0 up to 1, lower and upper bounds of the design variables;
   * The evaluation method was defined to adjust the 100-element PCA array based x array. Each field of the array x represents a feature in the 100-element PCA array. If the field in the vector x has a value less than 0.5, then the feature is dropped.
   * After that, the evaluation method train and test the model based on the new array generated from the previous step. The objective F1 is defined by the f1 score metric and the objective F2 is defined by the model prediction time.
2. NSGA-2 was defined to minimize the problem using a population of 100 elements over 100 generations;
3. The majority voting procedure define a problem as follows:
   * 300 design variables array, called x;
   * 2 objectives, called F1 and F2;
   * 0 up to 1, lower and upper bounds of the design variables;
   * The evaluation method was defined to adjust the 100-element PCA array from each view based x array. From 0 100 adjust the Apicalls array, from 100 to 200 adjust the Opcodes array, and from 200 to 300 adjust the Permissions array.
   * After that, the evaluation method train and test the same model based on the three new arrays generated from the previous step. From the prediction of each of the views, a new prediction array is generated using majority voting. Then, the f1 score metric is calculated and assigned to the objective F1. The sum of time to predict each view is assigned to objective F2.
4. NSGA-2 was defined to minimize the problem using a population of 300 elements over 100 generations;

##  Repo Directories

1. apks: lists of apks that were used in the project;
2. csv: csvs that were used in the project;
3. models: serialization of the models that were used in the item [Train and test models](#train-and-test-models);
4. src: all source codes that were used in this project;
